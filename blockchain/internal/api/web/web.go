package web

import (
	"blockchain/internal/api/web/server"
	"blockchain/internal/api/web/server/handlers"
	"blockchain/internal/api/web/server/models"
	"blockchain/internal/api/web/server/services"
	"blockchain/internal/core"
	"context"
	"fmt"
	"log"
	"net/http" // Import for http.ErrServerClosed
	"os/signal"
	"syscall"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

// gracefulShutdown listens for termination signals (SIGINT, SIGTERM), then gracefully shuts down the server.
func gracefulShutdown(e *echo.Echo, done chan bool) {
	// Create context that listens for the interrupt signal from the OS.
	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	// Listen for the interrupt signal.
	<-ctx.Done()

	log.Println("shutting down gracefully, press Ctrl+C again to force")

	// The context is used to inform the server it has 5 seconds to finish
	// the request it is currently handling
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := e.Shutdown(ctx); err != nil {
		log.Printf("Server forced to shutdown with error: %v", err)
	}

	log.Println("Server exiting")

	// Notify the main goroutine that the shutdown is complete
	done <- true
}

// CreateServer initializes the Echo server, starts it, and ensures graceful shutdown handling.
// The server runs in a goroutine to allow for concurrent shutdown handling via `gracefulShutdown`.
func CreateServer(chain *core.Blockchain) {
	e := echo.New()

	// Add Echo middleware (e.g., Logger, Recover)
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// Initialize all your services
	didService := services.NewDidService(chain)
	blockService := services.NewBlockService(chain)
	transactionService := services.NewTransactionService(chain)
	vcService := services.NewVCService(chain)

	// Create an instance of your server implementation
	myServer := &handlers.MyServer{
		DidService:         didService,
		BlockService:       blockService,
		TransactionService: transactionService,
		VCService:          vcService,
	}

	// Register the handlers generated by oapi-codegen
	models.RegisterHandlers(e, myServer)

	// Register any extra routes (status, swagger, static files)
	server.RegisterExtraRoutes(e)

	// Get server configuration, including the port
	config := server.NewConfiguration()

	done := make(chan bool, 1)

	go func() {
		err := e.Start(fmt.Sprintf(":%s", config.Port))
		if err != nil && err != http.ErrServerClosed {
			e.Logger.Fatal("shutting down the server", err)
		}
	}()

	go gracefulShutdown(e, done)

	<-done
	log.Println("Graceful shutdown complete.")
}
