// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package models

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ProofType.
const (
	ProofTypeEcdsaSecp256r1Signature2019 ProofType = "EcdsaSecp256r1Signature2019"
)

// Defines values for DidSchemaContext.
const (
	Httplocalhost8443docsdidSchemaHtml DidSchemaContext = "http://localhost:8443/docs/did.schema.html"
	HttpswwwW3Org2018credentialsv1     DidSchemaContext = "https://www.w3.org/2018/credentials/v1"
)

// Defines values for RequestDidCreateormodifySchemaProofType.
const (
	RequestDidCreateormodifySchemaProofTypeEcdsaSecp256r1Signature2019 RequestDidCreateormodifySchemaProofType = "EcdsaSecp256r1Signature2019"
)

// Defines values for RequestDidRevokeSchemaProofType.
const (
	RequestDidRevokeSchemaProofTypeEcdsaSecp256r1Signature2019 RequestDidRevokeSchemaProofType = "EcdsaSecp256r1Signature2019"
)

// Defines values for RequestVcCreateSchemaProofType.
const (
	RequestVcCreateSchemaProofTypeEcdsaSecp256r1Signature2019 RequestVcCreateSchemaProofType = "EcdsaSecp256r1Signature2019"
)

// N256Hash A SHA-256 or Keccak-256 hash of the complete VC in hexadecimal format.
type N256Hash = string

// DID DID string with the DID method `batterypass` followed by one of `eu, oem, cloud, bms, service` and then an identifier
type DID = string

// DateTime defines model for DateTime.
type DateTime = time.Time

// Proof Cryptographic proof that makes the subject verifiable.
type Proof struct {
	// Challenge Optional challenge to prevent replay attacks.
	Challenge *string   `json:"challenge,omitempty"`
	Created   time.Time `json:"created"`

	// Jws The actual signature in JSON Web Signature format
	Jws          string    `json:"jws"`
	ProofPurpose string    `json:"proofPurpose"`
	Type         ProofType `json:"type"`

	// VerificationMethod Reference to the key used to create the proof.
	VerificationMethod string `json:"verificationMethod"`
}

// ProofType defines model for Proof.Type.
type ProofType string

// ServiceEndpoint Represents a service associated with the DID subject, such as a metadata or data access point.
type ServiceEndpoint struct {
	// Id Identifier for the service endpoint, typically a DID fragment.
	Id string `json:"id"`

	// ServiceEndpoint The actual service endpoint, which can be a URL.
	ServiceEndpoint string `json:"serviceEndpoint"`

	// Type Type or category of the service, e.g., 'BatteryDataService'.
	Type string `json:"type"`
}

// URI An identifier in uri format for Verifiable Credentials
type URI = string

// DidSchema Minimal on-chain DID record with a revocation tag.
type DidSchema struct {
	// Context Defines the JSON-LD context, providing meaning to terms used in the did.
	Context []DidSchemaContext `json:"@context"`

	// Id DID string with the DID method `batterypass` followed by one of `eu, oem, cloud, bms, service` and then an identifier
	Id DID `json:"id"`

	// Revoked Boolean flag indicating whether this DID has been revoked.
	Revoked bool `json:"revoked"`

	// Service Optional array of service endpoints related to the DID subject, such as APIs or metadata services.
	Service   *[]ServiceEndpoint `json:"service,omitempty"`
	Timestamp DateTime           `json:"timestamp"`

	// VerificationMethod A method by which a DID subject can be authenticated, typically using cryptographic keys.
	VerificationMethod VerificationMethod `json:"verificationMethod"`
}

// DidSchemaContext defines model for DidSchema.Context.
type DidSchemaContext string

// RequestDidCreateormodifySchema defines model for request.did.createormodify.schema.
type RequestDidCreateormodifySchema struct {
	// Payload Minimal on-chain DID record with a revocation tag.
	Payload DidSchema `json:"payload"`
	Proof   struct {
		// Challenge Optional challenge to prevent replay attacks.
		Challenge string    `json:"challenge"`
		Created   time.Time `json:"created"`

		// Jws The actual signature in JSON Web Signature format
		Jws          string                                  `json:"jws"`
		ProofPurpose string                                  `json:"proofPurpose"`
		Type         RequestDidCreateormodifySchemaProofType `json:"type"`

		// VerificationMethod Reference to the key used to create the proof.
		VerificationMethod string `json:"verificationMethod"`
	} `json:"proof"`
}

// RequestDidCreateormodifySchemaProofType defines model for RequestDidCreateormodifySchema.Proof.Type.
type RequestDidCreateormodifySchemaProofType string

// RequestDidRevokeSchema defines model for request.did.revoke.schema.
type RequestDidRevokeSchema struct {
	// Payload DID string with the DID method `batterypass` followed by one of `eu, oem, cloud, bms, service` and then an identifier
	Payload DID `json:"payload"`
	Proof   struct {
		// Challenge Optional challenge to prevent replay attacks.
		Challenge string    `json:"challenge"`
		Created   time.Time `json:"created"`

		// Jws The actual signature in JSON Web Signature format
		Jws          string                          `json:"jws"`
		ProofPurpose string                          `json:"proofPurpose"`
		Type         RequestDidRevokeSchemaProofType `json:"type"`

		// VerificationMethod Reference to the key used to create the proof.
		VerificationMethod string `json:"verificationMethod"`
	} `json:"proof"`
}

// RequestDidRevokeSchemaProofType defines model for RequestDidRevokeSchema.Proof.Type.
type RequestDidRevokeSchemaProofType string

// RequestVcCreateSchema defines model for request.vc.create.schema.
type RequestVcCreateSchema struct {
	Payload struct {
		ExpirationDate *DateTime `json:"expirationDate,omitempty"`

		// Id An identifier in uri format for Verifiable Credentials
		Id URI `json:"id"`

		// VcHash A SHA-256 or Keccak-256 hash of the complete VC in hexadecimal format.
		VcHash N256Hash `json:"vcHash"`
	} `json:"payload"`
	Proof struct {
		// Challenge Optional challenge to prevent replay attacks.
		Challenge string    `json:"challenge"`
		Created   time.Time `json:"created"`

		// Jws The actual signature in JSON Web Signature format
		Jws          string                         `json:"jws"`
		ProofPurpose string                         `json:"proofPurpose"`
		Type         RequestVcCreateSchemaProofType `json:"type"`

		// VerificationMethod Reference to the key used to create the proof.
		VerificationMethod string `json:"verificationMethod"`
	} `json:"proof"`
}

// RequestVcCreateSchemaProofType defines model for RequestVcCreateSchema.Proof.Type.
type RequestVcCreateSchemaProofType string

// RequestVcRevokeSchema defines model for request.vc.revoke.schema.
type RequestVcRevokeSchema struct {
	// N256Hash A SHA-256 or Keccak-256 hash of the complete VC in hexadecimal format.
	N256Hash *N256Hash `json:"256Hash,omitempty"`

	// Id An identifier in uri format for Verifiable Credentials
	Id URI `json:"id"`
}

// RequestVcVerifySchema defines model for request.vc.verify.schema.
type RequestVcVerifySchema struct {
	// HolderDID DID string with the DID method `batterypass` followed by one of `eu, oem, cloud, bms, service` and then an identifier
	HolderDID DID `json:"holderDID"`

	// Id An identifier in uri format for Verifiable Credentials
	Id URI `json:"id"`

	// IssuerDID DID string with the DID method `batterypass` followed by one of `eu, oem, cloud, bms, service` and then an identifier
	IssuerDID DID `json:"issuerDID"`

	// VcHash A SHA-256 or Keccak-256 hash of the complete VC in hexadecimal format.
	VcHash *N256Hash `json:"vcHash,omitempty"`
}

// ResponseBlockSchema defines model for response.block.schema.
type ResponseBlockSchema struct {
	// Hash A SHA-256 or Keccak-256 hash of the complete VC in hexadecimal format.
	Hash  N256Hash `json:"Hash"`
	Index int      `json:"Index"`

	// MerkleRoot A SHA-256 or Keccak-256 hash of the complete VC in hexadecimal format.
	MerkleRoot N256Hash `json:"MerkleRoot"`

	// PreviousBlockHash A SHA-256 or Keccak-256 hash of the complete VC in hexadecimal format.
	PreviousBlockHash N256Hash `json:"PreviousBlockHash"`
	Timestamp         DateTime `json:"Timestamp"`

	// Transactions An array holding transactions contained in a block (DID Documents, VC Records)
	Transactions ResponseTransactionsSchema `json:"Transactions"`
}

// ResponseBlocksSchema An array holding transactions contained in a block (DID Documents, VC Records)
type ResponseBlocksSchema = []ResponseBlockSchema

// ResponseDidsSchema An array holding all DIDs in the blockchain
type ResponseDidsSchema = []DidSchema

// ResponseErrorSchema A standard error response structure for HTTP APIs.
type ResponseErrorSchema struct {
	// Message A human-readable error message.
	Message string `json:"message"`
}

// ResponseTransactionsSchema An array holding transactions contained in a block (DID Documents, VC Records)
type ResponseTransactionsSchema = []ResponseTransactionsSchema_Item

// ResponseTransactionsSchema_Item defines model for response.transactions.schema.Item.
type ResponseTransactionsSchema_Item struct {
	union json.RawMessage
}

// ResponseVcVerifySchema defines model for response.vc.verify.schema.
type ResponseVcVerifySchema struct {
	// HolderDID Minimal on-chain DID record with a revocation tag.
	HolderDID DidSchema `json:"holderDID"`

	// IssuerDID Minimal on-chain DID record with a revocation tag.
	IssuerDID DidSchema `json:"issuerDID"`
}

// VcRecordSchema Minimal record of a Verifiable Credential containing only its ID, a hash of the VC, a timestamp, and expiration date.
type VcRecordSchema struct {
	ExpirationDate *DateTime `json:"expirationDate,omitempty"`

	// Id An identifier in uri format for Verifiable Credentials
	Id        URI      `json:"id"`
	Timestamp DateTime `json:"timestamp"`

	// VcHash A SHA-256 or Keccak-256 hash of the complete VC in hexadecimal format.
	VcHash N256Hash `json:"vcHash"`
}

// VerificationMethod A method by which a DID subject can be authenticated, typically using cryptographic keys.
type VerificationMethod struct {
	// Controller DID that has the ability to make changes to this DID-Document.
	Controller string `json:"controller"`

	// Id Identifier for the verification method, typically a DID fragment.
	Id string `json:"id"`

	// PublicKeyMultibase The public key encoded in multibase format.
	PublicKeyMultibase string `json:"publicKeyMultibase"`

	// Type Type of the verification method, e.g., 'Ed25519VerificationKey2020'.
	Type string `json:"type"`
}

// CreateOrModifyDidJSONRequestBody defines body for CreateOrModifyDid for application/json ContentType.
type CreateOrModifyDidJSONRequestBody = RequestDidCreateormodifySchema

// RevokeDidJSONRequestBody defines body for RevokeDid for application/json ContentType.
type RevokeDidJSONRequestBody = RequestDidRevokeSchema

// CreateVcRecordJSONRequestBody defines body for CreateVcRecord for application/json ContentType.
type CreateVcRecordJSONRequestBody = RequestVcCreateSchema

// RevokeVcRecordJSONRequestBody defines body for RevokeVcRecord for application/json ContentType.
type RevokeVcRecordJSONRequestBody = RequestVcRevokeSchema

// VerifyVcRecordJSONRequestBody defines body for VerifyVcRecord for application/json ContentType.
type VerifyVcRecordJSONRequestBody = RequestVcVerifySchema

// AsDidSchema returns the union data inside the ResponseTransactionsSchema_Item as a DidSchema
func (t ResponseTransactionsSchema_Item) AsDidSchema() (DidSchema, error) {
	var body DidSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDidSchema overwrites any union data inside the ResponseTransactionsSchema_Item as the provided DidSchema
func (t *ResponseTransactionsSchema_Item) FromDidSchema(v DidSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDidSchema performs a merge with any union data inside the ResponseTransactionsSchema_Item, using the provided DidSchema
func (t *ResponseTransactionsSchema_Item) MergeDidSchema(v DidSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVcRecordSchema returns the union data inside the ResponseTransactionsSchema_Item as a VcRecordSchema
func (t ResponseTransactionsSchema_Item) AsVcRecordSchema() (VcRecordSchema, error) {
	var body VcRecordSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVcRecordSchema overwrites any union data inside the ResponseTransactionsSchema_Item as the provided VcRecordSchema
func (t *ResponseTransactionsSchema_Item) FromVcRecordSchema(v VcRecordSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVcRecordSchema performs a merge with any union data inside the ResponseTransactionsSchema_Item, using the provided VcRecordSchema
func (t *ResponseTransactionsSchema_Item) MergeVcRecordSchema(v VcRecordSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResponseTransactionsSchema_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResponseTransactionsSchema_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all blocks of the blockchain
	// (GET /api/v1/blocks)
	GetAllBlocks(ctx echo.Context) error
	// Get a block of the blockchain by ID
	// (GET /api/v1/blocks/{blockId})
	GetBlockById(ctx echo.Context, blockId int) error
	// Get all transactions of a specific block
	// (GET /api/v1/blocks/{blockId}/transactions)
	GetBlockTransactions(ctx echo.Context, blockId int) error
	// Get all DIDs from the blockchain
	// (GET /api/v1/dids)
	GetAllDids(ctx echo.Context) error
	// Create or modify a DID document
	// (POST /api/v1/dids/createormodify)
	CreateOrModifyDid(ctx echo.Context) error
	// Revoke a DID document
	// (POST /api/v1/dids/revoke)
	RevokeDid(ctx echo.Context) error
	// Get a specific DID Document by its DID
	// (GET /api/v1/dids/{did})
	GetDidById(ctx echo.Context, did string) error
	// Create a VC Record
	// (POST /api/v1/vc/create)
	CreateVcRecord(ctx echo.Context) error
	// Revoke a VC Record
	// (POST /api/v1/vc/revoke)
	RevokeVcRecord(ctx echo.Context) error
	// Verify a VC Record
	// (POST /api/v1/vc/verify)
	VerifyVcRecord(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAllBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllBlocks(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllBlocks(ctx)
	return err
}

// GetBlockById converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "blockId" -------------
	var blockId int

	err = runtime.BindStyledParameterWithOptions("simple", "blockId", ctx.Param("blockId"), &blockId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter blockId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockById(ctx, blockId)
	return err
}

// GetBlockTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "blockId" -------------
	var blockId int

	err = runtime.BindStyledParameterWithOptions("simple", "blockId", ctx.Param("blockId"), &blockId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter blockId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTransactions(ctx, blockId)
	return err
}

// GetAllDids converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllDids(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllDids(ctx)
	return err
}

// CreateOrModifyDid converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOrModifyDid(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOrModifyDid(ctx)
	return err
}

// RevokeDid converts echo context to params.
func (w *ServerInterfaceWrapper) RevokeDid(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RevokeDid(ctx)
	return err
}

// GetDidById converts echo context to params.
func (w *ServerInterfaceWrapper) GetDidById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "did" -------------
	var did string

	err = runtime.BindStyledParameterWithOptions("simple", "did", ctx.Param("did"), &did, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter did: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDidById(ctx, did)
	return err
}

// CreateVcRecord converts echo context to params.
func (w *ServerInterfaceWrapper) CreateVcRecord(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateVcRecord(ctx)
	return err
}

// RevokeVcRecord converts echo context to params.
func (w *ServerInterfaceWrapper) RevokeVcRecord(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RevokeVcRecord(ctx)
	return err
}

// VerifyVcRecord converts echo context to params.
func (w *ServerInterfaceWrapper) VerifyVcRecord(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VerifyVcRecord(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/blocks", wrapper.GetAllBlocks)
	router.GET(baseURL+"/api/v1/blocks/:blockId", wrapper.GetBlockById)
	router.GET(baseURL+"/api/v1/blocks/:blockId/transactions", wrapper.GetBlockTransactions)
	router.GET(baseURL+"/api/v1/dids", wrapper.GetAllDids)
	router.POST(baseURL+"/api/v1/dids/createormodify", wrapper.CreateOrModifyDid)
	router.POST(baseURL+"/api/v1/dids/revoke", wrapper.RevokeDid)
	router.GET(baseURL+"/api/v1/dids/:did", wrapper.GetDidById)
	router.POST(baseURL+"/api/v1/vc/create", wrapper.CreateVcRecord)
	router.POST(baseURL+"/api/v1/vc/revoke", wrapper.RevokeVcRecord)
	router.POST(baseURL+"/api/v1/vc/verify", wrapper.VerifyVcRecord)

}
