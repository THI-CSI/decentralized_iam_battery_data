/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/***********************************************************************************************************************
* Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/

#include "common_utils.h"
#include "crypto_ep.h"
#include "common.h"
#include "hal_data.h"
#include "mbedtls/pk.h"
#include "mbedtls/ecp.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* platform context structure.*/
mbedtls_platform_context ctx = {RESET_VALUE};

//psa_driver_wrapper_aead_encrypt()
/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
   fsp_pack_version_t version                   = {RESET_VALUE};
   psa_status_t       status                    = (psa_status_t)RESET_VALUE;
   int                mbed_ret_val              = RESET_VALUE;

   /* version get API for FLEX pack information */
   R_FSP_VersionGet(&version);

   /* Setup the platform; initialize the SCE */
   mbed_ret_val = mbedtls_platform_setup(&ctx);
   if (RESET_VALUE != mbed_ret_val)
   {
       APP_ERR_PRINT("\r\n** mbedtls_platform_setup API FAILED ** \r\n");
       APP_ERR_TRAP(mbed_ret_val);
   }

   /* Initialize crypto library.*/
   status = psa_crypto_init();
   if (PSA_SUCCESS != status)
   {
       APP_ERR_PRINT("\r\n** psa_crypto_init API FAILED ** \r\n");
       /* De-initialize the platform.*/
       mbedtls_platform_teardown(&ctx);
       APP_ERR_TRAP(status);
   }

   status = crypto_operations();
   if (PSA_SUCCESS != status)
   {
       // HPKE operation failed. Perform cleanup and trap error.
       handle_error(status, "\r\n** HPKE OPERATION FAILED ** \r\n");
   }

   APP_PRINT("\r\nCrypto Operations completed.\r\n");

   /* De-initialize the platform.*/
   mbedtls_psa_crypto_free();
   mbedtls_platform_teardown(&ctx);

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);

#if BSP_CFG_SDRAM_ENABLED

        /* Setup SDRAM and initialize it. Must configure pins first. */
        R_BSP_SdramInit(true);
#endif
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif

/*******************************************************************************************************************//**
 *  @brief       De-initialize the platform, print and trap error.
 *  @param[IN]   status    error status
 *  @param[IN]   err_str   error string
 *  @retval      None
 **********************************************************************************************************************/
psa_status_t crypto_operations() {

    /* Generating ephermal key pair */
    psa_status_t          status                              = (psa_status_t)RESET_VALUE;
    int                   mbedtls_status                      = RESET_VALUE;
    psa_key_attributes_t  ecc_attributes                      = PSA_KEY_ATTRIBUTES_INIT; // Contains key attributes.
    psa_key_handle_t      ecc_key_handle                      = {RESET_VALUE}; // ECC Key handle.
    uint8_t               ecc_pub_key[ECC_256_PUB_SIZE]       = {RESET_VALUE}; // Buffer where the public key data is to be written.
    size_t                ecc_pub_key_length                  = RESET_VALUE; // number of bytes that make up the public key data.
    char                  ecc_pub_key_der_encoded[ECC_256_PUB_DER_MAX_SIZE]        = {RESET_VALUE}; // Buffer where the public key (der-encoded) is to be written.
    uint8_t*              ecc_pub_key_der_write_ptr           = ecc_pub_key_der_encoded + sizeof(ecc_pub_key_der_encoded);
    size_t                ecc_pub_key_length_der_encoded      = RESET_VALUE; // number of bytes that make up the public key (der-encoded) data.

    // Set Key uses flags, key_algorithm, key_type, key_bits, key_lifetime, key_id
    psa_set_key_usage_flags(&ecc_attributes, PSA_KEY_USAGE_DERIVE);
    psa_set_key_algorithm(&ecc_attributes, PSA_ALG_KEY_AGREEMENT(PSA_ALG_ECDH, PSA_ALG_HKDF(PSA_ALG_SHA_256)));
    psa_set_key_type(&ecc_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR_WRAPPED(PSA_ECC_FAMILY_SECP_R1));
    psa_set_key_bits(&ecc_attributes, ECC_256_BIT_LENGTH);
    psa_set_key_lifetime(&ecc_attributes, PSA_KEY_LIFETIME_VOLATILE);

    // Generate ECC P256R1 Key pair
    status = psa_generate_key(&ecc_attributes, &ecc_key_handle);
    if (PSA_SUCCESS != status)
    {
        APP_ERR_PRINT("\r\n** psa_generate_key API FAILED ** \r\n");
        return status;
    }

    /* Export the public key.*/
    status = psa_export_public_key(ecc_key_handle, ecc_pub_key, ECC_256_PUB_SIZE , &ecc_pub_key_length);
    if (PSA_SUCCESS != status)
    {
        psa_destroy_key(ecc_key_handle);
        return status;
    }

    // Encode public key in DER format
    mbedtls_pk_context ctx_pk;
    mbedtls_pk_init(&ctx_pk);
    mbedtls_ecp_keypair *ecp = mbedtls_calloc(1, sizeof(mbedtls_ecp_keypair));
    mbedtls_ecp_keypair_init(ecp);
    mbedtls_status = mbedtls_ecp_group_load(&ecp->grp, MBEDTLS_ECP_DP_SECP256R1);
    mbedtls_status = mbedtls_ecp_point_read_binary(&ecp->grp, &ecp->Q, ecc_pub_key, ecc_pub_key_length);
    mbedtls_mpi_init(&ecp->d);
    mbedtls_status = mbedtls_pk_setup(&ctx_pk, mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY));
    ctx_pk.pk_ctx = ecp;
    ecc_pub_key_length_der_encoded = mbedtls_pk_write_pubkey_der(&ctx_pk, ecc_pub_key_der_encoded, sizeof(ecc_pub_key_der_encoded));

    uint8_t ecc_pub_key_der_encoded_stripped[ecc_pub_key_length_der_encoded];

    memcpy(ecc_pub_key_der_encoded_stripped, ecc_pub_key_der_write_ptr - ecc_pub_key_length_der_encoded, ecc_pub_key_length_der_encoded);

    //uint8_t pem_buf[300] = {RESET_VALUE}; //  Buffer to write to. The output includes a terminating null byte.
    //mbedtls_status = mbedtls_pk_write_pubkey_pem(&ctx_pk, pem_buf, sizeof(pem_buf));

    //uint8_t len = strlen((char*) pem_buf);
    //uint8_t pem_buf_stripped[len];
    //memcpy(pem_buf_stripped, pem_buf, len);

    //APP_PRINT((char*)pem_buf_stripped);

    /* Getting other required key material */
    psa_key_attributes_t  rec_attributes                      = PSA_KEY_ATTRIBUTES_INIT; // Contains key attributes.
    mbedtls_svc_key_id_t  rec_key_handle                      = {RESET_VALUE}; // REC Key handle.
    uint8_t               rec_pub_key[REC_PUB_KEY_BUFFER_LEN] = {RESET_VALUE}; // Buffer where the public key data is to be written.
    size_t                rec_pub_key_length                  = RESET_VALUE; // number of bytes that make up the public key data.

    // Setup key attributes
    psa_set_key_usage_flags(&rec_attributes, PSA_KEY_USAGE_DERIVE);
    psa_set_key_algorithm(&rec_attributes, PSA_ALG_ECDH);
    psa_set_key_type(&rec_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1));
    psa_set_key_bits(&rec_attributes, REC_KEY_BITS);
    psa_set_key_lifetime(&rec_attributes, PSA_KEY_LIFETIME_VOLATILE);

    // Generate ECC P256R1 Key pair
    status = psa_generate_key(&rec_attributes, &rec_key_handle);
    if (PSA_SUCCESS != status)
    {
        APP_ERR_PRINT("\r\n** psa_generate_key API FAILED ** \r\n");
        return status;
    }

    // Export the public key.
    status = psa_export_public_key(rec_key_handle, rec_pub_key, sizeof(rec_pub_key), &rec_pub_key_length);
    if (status != PSA_SUCCESS) {
        psa_destroy_key(rec_key_handle);
        return status;
    }

    // Delete key handle
    status = psa_destroy_key(rec_key_handle);
    if (PSA_SUCCESS != status)
    {
        APP_ERR_PRINT("\r\n** psa_destroy_key API FAILED ** \r\n");
        return status;
    }

    /* Creating shared secret with HKDF SHA2-256 */
    psa_key_derivation_operation_t      operation               = PSA_KEY_DERIVATION_OPERATION_INIT;    // Initialize the object to the initializer PSA_KEY_DERIVATION_OPERATION_INIT
    uint8_t                             salt[SALT_LENGTH]       = {RESET_VALUE};
    uint8_t                             info[INFO_LENGTH]       = {RESET_VALUE};
    psa_key_attributes_t                der_aes_key_attributes  = PSA_KEY_ATTRIBUTES_INIT;  // Contains generated key attributes.
    mbedtls_svc_key_id_t                der_aes_key_id          = RESET_VALUE;

    // Set Key uses flags, key_algorithm, key_type, key_bits, key_lifetime, key_id
    psa_set_key_usage_flags(&der_aes_key_attributes, PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&der_aes_key_attributes, PSA_ALG_GCM);
    psa_set_key_type(&der_aes_key_attributes, PSA_KEY_TYPE_AES);
    psa_set_key_bits(&der_aes_key_attributes, AES_KEY_BITS);
    psa_set_key_lifetime(&der_aes_key_attributes, PSA_KEY_LIFETIME_VOLATILE);

    status = psa_generate_random(salt, SALT_LENGTH);
    if (PSA_SUCCESS != status)
    {
        psa_destroy_key(ecc_key_handle);
        APP_ERR_PRINT("\r\n** psa_generate_random API FAILED ** \r\n");
        return status;
    }

    status = psa_key_derivation_setup(&operation, PSA_ALG_KEY_AGREEMENT(PSA_ALG_ECDH, PSA_ALG_HKDF(PSA_ALG_SHA_256)));
    if (PSA_SUCCESS != status)
    {
        psa_destroy_key(ecc_key_handle);
        APP_ERR_PRINT("\r\n** psa_key_derivation_setup API FAILED ** \r\n");
        return status;
    }

    status = psa_key_derivation_set_capacity(&operation, AES_KEY_BITS);
    if (PSA_SUCCESS != status)
    {
        psa_destroy_key(ecc_key_handle);
        psa_key_derivation_abort(&operation);
        APP_ERR_PRINT("\r\n** psa_key_derivation_set_capacity API FAILED ** \r\n");
        return status;
    }

    status = psa_key_derivation_input_bytes(&operation, PSA_KEY_DERIVATION_INPUT_SALT, salt, SALT_LENGTH);
    if (PSA_SUCCESS != status)
    {
        psa_destroy_key(ecc_key_handle);
        psa_key_derivation_abort(&operation);
        APP_ERR_PRINT("\r\n** psa_key_derivation_input_bytes API FAILED ** \r\n");
        return status;
    }

    status = psa_key_derivation_input_bytes(&operation, PSA_KEY_DERIVATION_INPUT_INFO, info, INFO_LENGTH);
    if (PSA_SUCCESS != status)
    {
        psa_destroy_key(ecc_key_handle);
        psa_key_derivation_abort(&operation);
        APP_ERR_PRINT("\r\n** psa_key_derivation_input_bytes API FAILED ** \r\n");
        return status;
    }

    status = psa_key_derivation_key_agreement(&operation, PSA_KEY_DERIVATION_INPUT_SECRET, ecc_key_handle, rec_pub_key, rec_pub_key_length);
    if (PSA_SUCCESS != status)
    {
        psa_destroy_key(ecc_key_handle);
        psa_key_derivation_abort(&operation);
        APP_ERR_PRINT("\r\n** psa_key_derivation_input_key_agreement API FAILED ** \r\n");
        return status;
    }

    status = psa_key_derivation_output_key(&der_aes_key_attributes, &operation, &der_aes_key_id);
    if (PSA_SUCCESS != status)
    {
        psa_destroy_key(ecc_key_handle);
        psa_destroy_key(der_aes_key_id);
        psa_key_derivation_abort(&operation);
        APP_ERR_PRINT("\r\n** psa_key_derivation_output_key API FAILED ** \r\n");
        return status;
    }

    status = psa_destroy_key(ecc_key_handle);
    if (PSA_SUCCESS != status)
    {
        psa_key_derivation_abort(&operation);
        APP_ERR_PRINT("\r\n** psa_destroy_key API FAILED ** \r\n");
        return status;
    }

    psa_key_derivation_abort(&operation);

    // Generate 96 bits nonce (IV)
    uint8_t nonce[NONCE_LENGTH] = {RESET_VALUE};
    uint8_t additional_data[12] = {RESET_VALUE};
    status = psa_generate_random(nonce, NONCE_LENGTH);
   if (PSA_SUCCESS != status)
   {
       APP_ERR_PRINT("\r\n** psa_generate_random API FAILED ** \r\n");
       return status;
   }

   uint8_t                *output_data1   = NULL;            // Output buffer for the decrypted data.
   size_t                 output_length1  = RESET_VALUE;     // the size of the output in the decrypted output buffer.
   uint8_t                *output_data    = NULL;            // Output buffer for the authenticated and encrypted data.
   size_t                 output_size     = RESET_VALUE;     // Size of the output buffer in bytes.
   size_t                 output_length   = RESET_VALUE;     // the size of the output in the encrypted output buffer.
   uint8_t                plain_battery_data[] = { 0xB9, 0x6B, 0x49, 0xE2, 0x1D, 0x62, 0x17, 0x41,
                                                   0x63, 0x28, 0x75, 0xDB, 0x7F, 0x6C, 0x92, 0x43,
                                                   0xD2, 0xD7, 0xC2 };
   uint8_t                aad[12] = {RESET_VALUE};

   APP_PRINT((char*) plain_battery_data);

   /* Calculate output size for encryption and decryption.*/
   output_size = sizeof(plain_battery_data) + TAG_LENGTH;
   output_data = (uint8_t *)malloc(output_size);
   output_data1 = (uint8_t *)malloc(output_size);

   if((NULL == output_data) || (NULL == output_data1))
   {
       APP_ERR_PRINT("\r\n** Out Of Memory. ** \r\n");
       return FSP_ERR_OUT_OF_MEMORY;
   }

   /* Authenticate and encrypt */
   status = psa_aead_encrypt(der_aes_key_id, PSA_ALG_GCM,
                             nonce, sizeof(nonce),
                             additional_data, sizeof(additional_data),
                             plain_battery_data, sizeof(plain_battery_data),
                             output_data, output_size,
                             &output_length);

   if (PSA_SUCCESS != status)
   {
       APP_ERR_PRINT("\r\n** psa_aead_encrypt API FAILED ** \r\n");
       return status;
   }

   /* Authenticate and decrypt */
   status = psa_aead_decrypt(der_aes_key_id, PSA_ALG_GCM,
                             nonce, sizeof(nonce),
                             additional_data, sizeof(additional_data),
                             output_data, output_length,
                             output_data1, output_length,
                             &output_length1);
   if (PSA_SUCCESS != status)
   {
       APP_ERR_PRINT("\r\n** psa_aead_decrypt API FAILED ** \r\n");
       return status;
   }

   APP_PRINT((char*) output_data1);

   /* Compare the encrypted data length and decrypted data length.*/
   if(output_length1 != sizeof(plain_battery_data))
   {
       APP_ERR_PRINT("\r\n** Comparison of encrypted data length and decrypted data length failed.** \r\n");
       return FSP_ERR_CRYPTO_INVALID_SIZE;
   }

   /* Compare the encrypted data and decrypted data.*/
   for(int len = RESET_VALUE; len < (int )output_length1; len++)
   {
       if(plain_battery_data[len] != *output_data1)
       {
           APP_ERR_PRINT("\r\n** Comparison of encrypted data and decrypted data failed.** \r\n");
           return FSP_ERR_ABORTED;
       }
       output_data1++;
   }

    return status;

}

/*******************************************************************************************************************//**
 *  @brief       Initialize Littlefs operation.
 *  @param[IN]   None
 *  @retval      FSP_SUCCESS or any other possible error code
 **********************************************************************************************************************/
fsp_err_t littlefs_init(void)
{
    fsp_err_t          err                       = FSP_SUCCESS;
    int                lfs_err                   = RESET_VALUE;

    /* Open LittleFS Flash port.*/
    err = RM_LITTLEFS_FLASH_Open(&g_rm_littlefs0_ctrl, &g_rm_littlefs0_cfg);
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\n** RM_LITTLEFS_FLASH_Open API FAILED ** \r\n");
        return err;
    }

    /* Format the filesystem. */
    lfs_err = lfs_format(&g_rm_littlefs0_lfs, &g_rm_littlefs0_lfs_cfg);
    if(RESET_VALUE != lfs_err)
    {
        APP_ERR_PRINT("\r\n** lfs_format API FAILED ** \r\n");
        deinit_littlefs();
        return (fsp_err_t)lfs_err;
    }

    /* Mount the filesystem. */
    lfs_err = lfs_mount(&g_rm_littlefs0_lfs, &g_rm_littlefs0_lfs_cfg);
    if(RESET_VALUE != lfs_err)
    {
        APP_ERR_PRINT("\r\n** lfs_mount API FAILED ** \r\n");
        deinit_littlefs();
        return (fsp_err_t)lfs_err;
    }
    return err;
}

/*******************************************************************************************************************//**
 *  @brief       De-Initialize the Littlefs.
 *  @param[IN]   None
 *  @retval      None
 **********************************************************************************************************************/
void deinit_littlefs(void)
{
    fsp_err_t          err                       = FSP_SUCCESS;
    /*Closes the lower level driver */
    err = RM_LITTLEFS_FLASH_Close(&g_rm_littlefs0_ctrl);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\n** RM_LITTLEFS_FLASH_Close API FAILED ** \r\n");
    }
}

/*******************************************************************************************************************//**
 *  @brief       De-initialize the platform, print and trap error.
 *  @param[IN]   status    error status
 *  @param[IN]   err_str   error string
 *  @retval      None
 **********************************************************************************************************************/
void handle_error(psa_status_t status, char * err_str)
{
    mbedtls_psa_crypto_free();
    /* De-initialize the platform.*/
    mbedtls_platform_teardown(&ctx);
    APP_ERR_PRINT(err_str);
    APP_ERR_TRAP(status);
}
